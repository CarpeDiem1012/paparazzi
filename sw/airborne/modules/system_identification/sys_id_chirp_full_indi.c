/*
 * Copyright (C) Dennis van Wijngaarden <D.C.vanWIjngaarden@tudelft.nl>
 *
 * This file is part of paparazzi
 *
 * paparazzi is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2, or (at your option)
 * any later version.
 *
 * paparazzi is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with paparazzi; see the file COPYING.  If not, see
 * <http://www.gnu.org/licenses/>.
 */

/** @file "modules/system_identification/sys_id_chirp_full_indi.c"
 * @author Dennis van Wijngaarden <D.C.vanWIjngaarden@tudelft.nl>
 * This module will add phi, theta and psi commands in terms of chrirps to the quat setpoint generated by stabilization_indi
 */

#include "sys_id_chirp_full_indi.h"
#include "pprz_chirp.h"

#include "subsystems/datalink/telemetry.h"
#include "subsystems/radio_control.h"
#include "generated/airframe.h"
#include "mcu_periph/sys_time.h"

#include "std.h"

#define CHIRP_NB_AXES 3

#ifndef CHIRP_ENABLED
#define CHIRP_ENABLED TRUE
#endif

#ifndef CHIRP_EXPONENTIAL
#define CHIRP_EXPONENTIAL TRUE
#endif

#ifndef CHIRP_FADEIN
#define CHIRP_FADEIN TRUE
#endif

#ifndef CHIRP_DELAY_S // Chirp Delay s
#define CHIRP_DELAY_S 2.0
#endif

static struct chirp_t chirp;
uint8_t chirp_active = false;  // Boolean to check if chirp is active
uint8_t chirp_axis = 0;    // Chrip axis (roll, pitch, yaw)
float chirp_amplitude = 0; // Chirp amplitude in degrees
float chirp_fstart_hz = 1.0; // Start frequency of chrirp
float chirp_fstop_hz = 5.0;  // Stop frequency of chrirp
float chirp_length_s = 5.0;  // Length of chirp

static float current_chirp_values[CHIRP_NB_AXES];

static bool rc_chirp_on = false; // Gives the state of the chirp switch
static bool delayed_chirp_activated = false;
static float delayed_chirp_time = 0;


static void set_current_chirp_values(void)
{
  if (chirp_active) {

    current_chirp_values[chirp_axis] = (float)(chirp_amplitude * chirp.current_value);
  } else {
    for (uint8_t i = 0; i < CHIRP_NB_AXES; i++) {
      current_chirp_values[i] = 0;
    }
  }
}

static void send_chirp(struct transport_tx *trans, struct link_device *dev)
{
  pprz_msg_send_CHIRP(trans, dev, AC_ID, &chirp_active, &chirp.percentage_done, &chirp.current_frequency_hz,
                      &chirp_axis, &chirp_amplitude, &chirp_fstart_hz, &chirp_fstop_hz, 0,
                      0);
}

static void start_chirp(void)
{
  chirp_reset(&chirp, get_sys_time_float());
  chirp_active = true;
  set_current_chirp_values();
}

static void start_chirp_delayed(void)
{
  delayed_chirp_activated = true;
  delayed_chirp_time = get_sys_time_float();
}

static void check_chirp_delayed(void)
{
  if (delayed_chirp_activated) {
    if ((get_sys_time_float() - delayed_chirp_time) > CHIRP_DELAY_S) {
      chirp_init(&chirp, chirp_fstart_hz, chirp_fstop_hz, chirp_length_s, get_sys_time_float(), CHIRP_EXPONENTIAL,
               CHIRP_FADEIN);
      start_chirp();
      delayed_chirp_activated = false;
    }
  }
}

static void stop_chirp(void)
{
  chirp_reset(&chirp, get_sys_time_float());
  chirp_active = false;
  set_current_chirp_values();
  delayed_chirp_activated = false;
}

void sys_id_chirp_full_indi_activate_handler(uint8_t activate)
{
  chirp_active = activate;
  if (chirp_active) {
    chirp_init(&chirp, chirp_fstart_hz, chirp_fstop_hz, chirp_length_s, get_sys_time_float(), CHIRP_EXPONENTIAL,
               CHIRP_FADEIN);
    start_chirp();
  } else {
    stop_chirp();
  }
}

void sys_id_chirp_full_indi_axis_handler(uint8_t axis)
{
  if (axis < CHIRP_NB_AXES) {
    chirp_axis = axis;
  }
}

void sys_id_chirp_full_indi_fstart_handler(float fstart)
{
  if (fstart < chirp_fstop_hz) {
    chirp_fstart_hz = fstart;
  }
}

void sys_id_chirp_full_indi_fstop_handler(float fstop)
{
  if (fstop > chirp_fstart_hz) {
    chirp_fstop_hz = fstop;
  }
}

void sys_id_chirp_full_indi_init(void)
{
  chirp_init(&chirp, chirp_fstart_hz, chirp_fstop_hz, chirp_length_s, get_sys_time_float(), CHIRP_EXPONENTIAL,
             CHIRP_FADEIN);
  set_current_chirp_values();
  register_periodic_telemetry(DefaultPeriodic, PPRZ_MSG_ID_CHIRP, send_chirp);
}

void sys_id_chirp_full_indi_run(void)
{
#if CHIRP_ENABLED

  // Check if chirp needs to be activated by RC
  #ifdef CHIRP_ACTIVATE_RC_CHANNEL
  #ifdef CHIRP_ACTIVATE_RC_THRESHOLD
    // If the switch was not switched before:
    if (!rc_chirp_on) {
      // If switch has been switched
      if (radio_control.values[CHIRP_ACTIVATE_RC_CHANNEL] > CHIRP_ACTIVATE_RC_THRESHOLD) {
        rc_chirp_on = true;
        start_chirp_delayed();
      }
    } else { // If the switch switches back
      if (radio_control.values[CHIRP_ACTIVATE_RC_CHANNEL] < CHIRP_ACTIVATE_RC_THRESHOLD) {
        rc_chirp_on = false;
        stop_chirp();
      }
    }
  #endif
  #endif
  check_chirp_delayed();

  if (chirp_active) {
    if (!chirp_is_running(&chirp, get_sys_time_float())) {
      stop_chirp();
    } else {
      chirp_update(&chirp, get_sys_time_float());
      set_current_chirp_values();
    }
  }

#endif
}

void sys_id_chirp_full_indi_add_values(struct Int32Quat *quat_sp)
{
  #if CHIRP_ENABLED

    // Convert quat setpoint to euler angles
    struct Int32Eulers eulers_sp_int;
    struct FloatEulers eulers_sp_float;
    int32_eulers_of_quat(&eulers_sp_int, quat_sp);
    EULERS_FLOAT_OF_BFP(eulers_sp_float, eulers_sp_int);

    // Add chirp eulers to each axis
    eulers_sp_float.phi += current_chirp_values[0] / 180. * M_PI;
    eulers_sp_float.theta += current_chirp_values[1] / 180. * M_PI;
    eulers_sp_float.psi += current_chirp_values[2] / 180. * M_PI;

    // Bound al setpoints 
    BoundAbs(eulers_sp_float.phi, STABILIZATION_ATTITUDE_SP_MAX_PHI);
    BoundAbs(eulers_sp_float.theta, STABILIZATION_ATTITUDE_SP_MAX_THETA);
    BoundAbs(eulers_sp_float.psi, STABILIZATION_ATTITUDE_SP_MAX_R);

    // Convert back to quat
    EULERS_BFP_OF_REAL(eulers_sp_int, eulers_sp_float);
    int32_quat_of_eulers(quat_sp, &eulers_sp_int);
  #endif
}

